package librsync

import "github.com/dchest/siphash"

const (
	// generated by splitting the md5 sum of "hashmap"
	sipHashKey1 = 0xdda7806a4847ec61
	sipHashKey2 = 0xb5940c2623a5aabd
)

// block2hash converts a []byte into a value suitable for keying a map. This
// code is based on the method used in `github.com/cornelk/hashmap` for making
// []byte into a hashable key
func block2hash(s []byte) uintptr {
	return uintptr(siphash.Hash(sipHashKey1, sipHashKey2, s))
}

// StrongSignatureHashMap is used to map from a strong checksum to a position in
// the file.
type StrongSignatureHashMap struct {
	Strong map[uintptr]int
}

// SignatureHashMap maps a weak checksum to a hash of strong checksums for
// blocks that have the same weak checksum. In order to fully match a block of
// data, the weak checksum is used to get a StrongSignatureHashMap, and then the
// strong checksum is used to get the position of the block that matches both
// the weak sum and the strong sum.
type SignatureHashMap struct {
	Weak map[uint32]StrongSignatureHashMap
}

// Get returns the StrongSignatureHashMap for the provided weak checksum. In
// addition to the StrongSignatureHashMap, a boolean value will be returned,
// with `true` indicating that the weak checksum was found, and `false`
// indicating that it was not found.
func (h *SignatureHashMap) Get(k uint32) (StrongSignatureHashMap, bool) {
	v, ok := h.Weak[k]
	return v, ok
}

// Set associates weak sum `k` with the StrongSignatureHashMap `v`.
func (h *SignatureHashMap) Set(k uint32, v StrongSignatureHashMap) {
	h.Weak[k] = v
}

// UpdateBlock adds the signature mappings for the data block at position
// `l`, having weak checkum `w` and strong checksum `s`.
func (h *SignatureHashMap) UpdateBlock(w uint32, s []byte, l int) {
	key := block2hash(s)
	st, ok := h.Get(w)
	if !ok {
		st = newStrongMap()
		h.Set(w, st)
	}
	st.Set(key, l)
}

// Get returns the position of the data block with strong checksum `k`
func (h *StrongSignatureHashMap) Get(k []byte) (int, bool) {
	key := block2hash(k)
	v, ok := h.Strong[key]
	return v, ok
}

// Set stores the position `l` for the block with strong checksum `k`
func (h *StrongSignatureHashMap) Set(k uintptr, l int) {
	h.Strong[k] = l
}

// newStrongMap properly initializes a new StrongSignatureHashMap so that it can
// be updated, and returns the new StrongSignatureHashMap
func newStrongMap() StrongSignatureHashMap {
	st := make(map[uintptr]int)
	h := StrongSignatureHashMap{Strong: st}
	return h
}

// NewSignatureHashMap initializes a new SignatureHashMap so that
// StrongSignatureHashMaps can be added to it, and returns the new
// SignatureHashMap
func NewSignatureHashMap() SignatureHashMap {
	w := make(map[uint32]StrongSignatureHashMap)
	return SignatureHashMap{Weak: w}
}
